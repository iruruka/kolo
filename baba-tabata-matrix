// 行列のサイズを定義
int N = 2;
int n = (N+1)*(N+1);//n=4225
int m = (N+1)*(N+1);//m=4225
mesh Th = square(N, N);
fespace Vh(Th, P1);
Vh u;
Vh v, vold;
v = 500 * exp(-50 * (x*x + y*y));

// n x m のゼロ行列を作成
matrix A(n, m);
matrix BP(n, m);
matrix BM(n, m);

////////////////////////////////////BPの作製/////////////////////////////////////////////////////////
//左下の角, i=0
for(int i = 0; i < 1; i++) {
    BP(i, i+1) += max(0.0, (3*v[][i+1]-2*v[][i]-v[][i+N+2])/6);//右　(1)⇀
    BP(i, i+N+1) += max(0.0, (3*v[][i+N+1]-2*v[][i]-v[][i+N+2])/6);//上　(2)↾
    BP(i, i+N+2) += max(0.0, (v[][i+N+2]-v[][i])/3);//右上　(3)↗
}

//右下の角, i=64
for(int i = N; i < N+1; i++) {
    BP(i, i-1) += max(0.0, (2*v[][i-1]+v[][i+N+1]-3*v[][i])/6);//左　(4)↼
    BP(i, i+N+1) += max(0.0, (2*v[][i+N+1]+v[][i-1]-3*v[][i])/6);//上　(5)↿
}

//左上の角, i=4160
for(int i = N*(N+1); i < N*(N+1)+1; i++) {
    BP(i, i-(N+1)) += max(0.0, (2*v[][i-(N+1)]+v[][i+1]-3*v[][i])/6);//下　(6)⇂
    BP(i, i+1) += max(0.0, (2*v[][i+1]+v[][i-(N+1)]-3*v[][i])/6);//右　(7)⇁
}

//右上の角, i=4224
for(int i = (N+1)*(N+1)-1; i < (N+1)*(N+1); i++) {
    BP(i, i-(N+2)) += max(0.0, (v[][i-(N+2)]-v[][i])/3);//左下　(8)↙
    BP(i, i-(N+1)) += max(0.0, (3*v[][i-(N+1)]-2*v[][i]-v[][i-(N+2)])/6);//下　(9)⇃
    BP(i, i-1) += max(0.0, (3*v[][i-1]-2*v[][i]-v[][i-(N+2)])/6);//左　(10)↽
}

//領域の下辺, i=1~63
for(int i = 1; i < N; i++) {
    BP(i, i-1) += max(0.0, (2*v[][i-1]+v[][i+N+1]-3*v[][i])/6);//左　(4)↼
    BP(i, i+1) += max(0.0, (3*v[][i+1]-2*v[][i]-v[][i+N+2])/6);//右　(1)⇀
    BP(i, i+N+1) += max(0.0, (2*v[][i+N+1]+v[][i-1]-3*v[][i])/6)+max(0.0, (3*v[][i+N+1]-2*v[][i]-v[][i+N+2])/6);//上　(5)↿ + (2)↾
    BP(i, i+N+2) += max(0.0, (v[][i+N+2]-v[][i])/3);//右上　(3)↗
}

//領域の上辺, i=4161~4223
for(int i = 4161; i < m-1; i++) {
    BP(i, i-(N+2)) += max(0.0, (v[][i-(N+2)]-v[][i])/3);//左下　(8)↙
    BP(i, i-(N+1)) += max(0.0, (3*v[][i-(N+1)]-2*v[][i]-v[][i-(N+2)])/6)+max(0.0, (2*v[][i-(N+1)]+v[][i+1]-3*v[][i])/6);//下　(9)⇃ + (6)⇂
    BP(i, i-1) += max(0.0, (3*v[][i-1]-2*v[][i]-v[][i-(N+2)])/6);//左　(10)↽
    BP(i, i+1) += max(0.0, (2*v[][i+1]+v[][i-(N+1)]-3*v[][i])/6);//右　(7)⇁
}

//領域の左辺, i=65,130,...,4095
for(int i = N+1; i < m-(N+1); i += N+1) {
    BP(i, i-(N+1)) += max(0.0, (2*v[][i-(N+1)]+v[][i+1]-3*v[][i])/6);//下　(6)⇂
    BP(i, i+1) += max(0.0, (3*v[][i+1]-2*v[][i]-v[][i+N+2])/6)+max(0.0, (2*v[][i+1]+v[][i-(N+1)]-3*v[][i])/6);//右　(1)⇀ + (7)⇁
    BP(i, i+N+1) += max(0.0, (3*v[][i+N+1]-2*v[][i]-v[][i+N+2])/6);//上　(2)↾
    BP(i, i+N+2) += max(0.0, (v[][i+N+2]-v[][i])/3);//右上　(3)↗
}

//領域の右辺, i=129,194,...,4159
for(int i = N+(N+1); i < m-(N+1); i += N+1) {
    BP(i, i-(N+2)) += max(0.0, (v[][i-(N+2)]-v[][i])/3);//左下　(8)↙
    BP(i, i-(N+1)) += max(0.0, (3*v[][i-(N+1)]-2*v[][i]-v[][i-(N+2)])/6);//下　(9)⇃
    BP(i, i-1) += max(0.0, (2*v[][i-1]+v[][i+N+1]-3*v[][i])/6)+max(0.0, (3*v[][i-1]-2*v[][i]-v[][i-(N+2)])/6);//左　(4)↼ + (10)↽
    BP(i, i+N+1) += max(0.0, (2*v[][i+N+1]+v[][i-1]-3*v[][i])/6);//上　(5)↿
}

//領域の内部, i=66~128,...,4096~4158
for(int i = N+2; i < n-N-2; i++) {
    if(i%(N+1)!=0 || (i-N)%(N+1)!=0){
    BP(i, i-(N+2)) += max(0.0, (v[][i-(N+2)]-v[][i])/3);//左下　(8)↙
    BP(i, i-(N+1)) += max(0.0, (3*v[][i-(N+1)]-2*v[][i]-v[][i-(N+2)])/6)+max(0.0, (2*v[][i-(N+1)]+v[][i+1]-3*v[][i])/6);//下　(9)⇃ + (6)⇂
    BP(i, i-1) += max(0.0, (2*v[][i-1]+v[][i+N+1]-3*v[][i])/6)+max(0.0, (3*v[][i-1]-2*v[][i]-v[][i-(N+2)])/6);//左　(4)↼ + (10)↽
    BP(i, i+1) += max(0.0, (3*v[][i+1]-2*v[][i]-v[][i+N+2])/6)+max(0.0, (2*v[][i+1]+v[][i-(N+1)]-3*v[][i])/6);//右　(1)⇀ + (7)⇁
    BP(i, i+N+1) += max(0.0, (2*v[][i+N+1]+v[][i-1]-3*v[][i])/6)+max(0.0, (3*v[][i+N+1]-2*v[][i]-v[][i+N+2])/6);//上　(5)↿ + (2)↾
    BP(i, i+N+2) += max(0.0, (v[][i+N+2]-v[][i])/3);//右上　(3)↗
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////BMの作製/////////////////////////////////////////////////////////
//左下の角, i=0
for(int i = 0; i < 1; i++) {
    BM(i, i+1) += max(0.0, -(3*v[][i+1]-2*v[][i]-v[][i+N+2])/6);//右　(1)⇀
    BM(i, i+N+1) += max(0.0, -(3*v[][i+N+1]-2*v[][i]-v[][i+N+2])/6);//上　(2)↾
    BM(i, i+N+2) += max(0.0, -(v[][i+N+2]-v[][i])/3);//右上　(3)↗
}

//右下の角, i=64
for(int i = N; i < N+1; i++) {
    BM(i, i-1) += max(0.0, -(2*v[][i-1]+v[][i+N+1]-3*v[][i])/6);//左　(4)↼
    BM(i, i+N+1) += max(0.0, -(2*v[][i+N+1]+v[][i-1]-3*v[][i])/6);//上　(5)↿
}

//左上の角, i=4160
for(int i = N*(N+1); i < N*(N+1)+1; i++) {
    BM(i, i-(N+1)) += max(0.0, -(2*v[][i-(N+1)]+v[][i+1]-3*v[][i])/6);//下　(6)⇂
    BM(i, i+1) += max(0.0, -(2*v[][i+1]+v[][i-(N+1)]-3*v[][i])/6);//右　(7)⇁
}

//右上の角, i=4224
for(int i = (N+1)*(N+1)-1; i < (N+1)*(N+1); i++) {
    BM(i, i-(N+2)) += max(0.0, -(v[][i-(N+2)]-v[][i])/3);//左下　(8)↙
    BM(i, i-(N+1)) += max(0.0, -(3*v[][i-(N+1)]-2*v[][i]-v[][i-(N+2)])/6);//下　(9)⇃
    BM(i, i-1) += max(0.0, -(3*v[][i-1]-2*v[][i]-v[][i-(N+2)])/6);//左　(10)↽
}

//領域の下辺, i=1~63
for(int i = 1; i < N; i++) {
    BM(i, i-1) += max(0.0, -(2*v[][i-1]+v[][i+N+1]-3*v[][i])/6);//左　(4)↼
    BM(i, i+1) += max(0.0, -(3*v[][i+1]-2*v[][i]-v[][i+N+2])/6);//右　(1)⇀
    BM(i, i+N+1) += max(0.0, -(2*v[][i+N+1]+v[][i-1]-3*v[][i])/6)+max(0.0, -(3*v[][i+N+1]-2*v[][i]-v[][i+N+2])/6);//上　(5)↿ + (2)↾
    BM(i, i+N+2) += max(0.0, -(v[][i+N+2]-v[][i])/3);//右上　(3)↗
}

//領域の上辺, i=4161~4223
for(int i = 4161; i < m-1; i++) {
    BM(i, i-(N+2)) += max(0.0, -(v[][i-(N+2)]-v[][i])/3);//左下　(8)↙
    BM(i, i-(N+1)) += max(0.0, -(3*v[][i-(N+1)]-2*v[][i]-v[][i-(N+2)])/6)+max(0.0, -(2*v[][i-(N+1)]+v[][i+1]-3*v[][i])/6);//下　(9)⇃ + (6)⇂
    BM(i, i-1) += max(0.0, -(3*v[][i-1]-2*v[][i]-v[][i-(N+2)])/6);//左　(10)↽
    BM(i, i+1) += max(0.0, -(2*v[][i+1]+v[][i-(N+1)]-3*v[][i])/6);//右　(7)⇁
}

//領域の左辺, i=65,130,...,4095
for(int i = N+1; i < m-(N+1); i += N+1) {
    BM(i, i-(N+1)) += max(0.0, -(2*v[][i-(N+1)]+v[][i+1]-3*v[][i])/6);//下　(6)⇂
    BM(i, i+1) += max(0.0, -(3*v[][i+1]-2*v[][i]-v[][i+N+2])/6)+max(0.0, -(2*v[][i+1]+v[][i-(N+1)]-3*v[][i])/6);//右　(1)⇀ + (7)⇁
    BM(i, i+N+1) += max(0.0, -(3*v[][i+N+1]-2*v[][i]-v[][i+N+2])/6);//上　(2)↾
    BM(i, i+N+2) += max(0.0, -(v[][i+N+2]-v[][i])/3);//右上　(3)↗
}

//領域の右辺, i=129,194,...,4159
for(int i = N+(N+1); i < m-(N+1); i += N+1) {
    BM(i, i-(N+2)) += max(0.0, -(v[][i-(N+2)]-v[][i])/3);//左下　(8)↙
    BM(i, i-(N+1)) += max(0.0, -(3*v[][i-(N+1)]-2*v[][i]-v[][i-(N+2)])/6);//下　(9)⇃
    BM(i, i-1) += max(0.0, -(2*v[][i-1]+v[][i+N+1]-3*v[][i])/6)+max(0.0, -(3*v[][i-1]-2*v[][i]-v[][i-(N+2)])/6);//左　(4)↼ + (10)↽
    BM(i, i+N+1) += max(0.0, -(2*v[][i+N+1]+v[][i-1]-3*v[][i])/6);//上　(5)↿
}

//領域の内部, i=66~128,...,4096~4158
for(int i = N+2; i < n-N-2; i++) {
    if(i%(N+1)!=0 || (i-N)%(N+1)!=0){
    BM(i, i-(N+2)) += max(0.0, -(v[][i-(N+2)]-v[][i])/3);//左下　(8)↙
    BM(i, i-(N+1)) += max(0.0, -(3*v[][i-(N+1)]-2*v[][i]-v[][i-(N+2)])/6)+max(0.0, -(2*v[][i-(N+1)]+v[][i+1]-3*v[][i])/6);//下　(9)⇃ + (6)⇂
    BM(i, i-1) += max(0.0, -(2*v[][i-1]+v[][i+N+1]-3*v[][i])/6)+max(0.0, -(3*v[][i-1]-2*v[][i]-v[][i-(N+2)])/6);//左　(4)↼ + (10)↽
    BM(i, i+1) += max(0.0, -(3*v[][i+1]-2*v[][i]-v[][i+N+2])/6)+max(0.0, -(2*v[][i+1]+v[][i-(N+1)]-3*v[][i])/6);//右　(1)⇀ + (7)⇁
    BM(i, i+N+1) += max(0.0, -(2*v[][i+N+1]+v[][i-1]-3*v[][i])/6)+max(0.0, -(3*v[][i+N+1]-2*v[][i]-v[][i+N+2])/6);//上　(5)↿ + (2)↾
    BP(i, i+N+2) += max(0.0, -(v[][i+N+2]-v[][i])/3);//右上　(3)↗
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////Aの作製/////////////////////////////////////////////////////////

// A の対角成分に BP の i 行の総和を代入
for(int i = 0; i < n; i++) {
    real rowSum = 0.0;
    for(int j = 0; j < m; j++) {
        rowSum += BP(i, j);
    }
    A(i, i) = rowSum;
}

// A の非対角成分に -BM(i,j) を代入
for(int i = 0; i < n; i++) {
    for(int j = 0; j < m; j++) {
        if(i != j) {
            A(i, j) = -BM(i, j);
        }
    }
}

// 行列BPの要素をCSV形式で書き出す
ofstream csvFile1("baba_tabata_matrix_output_BP.csv");
for(int i = 0; i < n; i++) {
    for(int j = 0; j < m; j++) {
        csvFile1 << BP(i, j);
        if(j < m-1) {
            csvFile1 << ","; // 列の区切り
        }
    }
    csvFile1 << "\n"; // 行の区切り
}

// 行列BMの要素をCSV形式で書き出す
ofstream csvFile2("baba_tabata_matrix_output_BM.csv");
for(int i = 0; i < n; i++) {
    for(int j = 0; j < m; j++) {
        csvFile2 << BM(i, j);
        if(j < m-1) {
            csvFile2 << ","; // 列の区切り
        }
    }
    csvFile2 << "\n"; // 行の区切り
}

// 行列Aの要素をCSV形式で書き出す
ofstream csvFile3("baba_tabata_matrix_output_A.csv");
for(int i = 0; i < n; i++) {
    for(int j = 0; j < m; j++) {
        csvFile3 << A(i, j);
        if(j < m-1) {
            csvFile3 << ","; // 列の区切り
        }
    }
    csvFile3 << "\n"; // 行の区切り
}
